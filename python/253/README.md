# No.253

## 問題文

**最短カバレッジ区間（サービス呼び出しログ）**

到着順のサービス名ログ `logs`（文字列の配列）と、

少なくとも1回は含めたいサービス集合 `need`（重複なしの集合）が与えられる。

`logs` の**連続区間**のうち、`need` に含まれるすべてのサービスを**少なくとも1回**含むものの**最短の区間 [L, R]（両端インデックス, 0-based, L ≤ R）**を返せ。

もし存在しなければ空配列 `[]` を返せ。

* `0 ≤ len(logs) ≤ 2 * 10^5`
* 各 `logs[i]` は非空文字列
* `0 ≤ len(need) ≤ min(10^5, 異なるサービス数)`
* 期待計算量: **O(n)**、追加メモリ **O(|need|)**

## 実行例

**例1**

```
入力:
logs = ["auth","pay","search","auth","cart","pay","search"]
need = {"pay","search"}
出力:
[1, 2]
説明:
logs[1..2] = ["pay","search"] が最短（長さ2）。他に [5,6] もあるが同じ長さ。
```

**例2**

```
入力:
logs = ["A","B","A","C","B","A"]
need = {"A","B","C"}
出力:
[1, 3]
説明:
logs[1..3] = ["B","A","C"] が最短（長さ3）。
```

**例3**

```
入力:
logs = ["x","y"]
need = {"z"}
出力:
[]
```

**例4**

```
入力:
logs = []
need = {"a"}
出力:
[]
```

**例5**

```
入力:
logs = ["only"]
need = {"only"}
出力:
[0, 0]
```

## 実行結果

```
[1, 2]
[1, 3]
[]
[]
[0, 0]
```
