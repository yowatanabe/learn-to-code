# No.306

## 問題: 文字列をシフトして同一にできるか（Minimum Shifts to Make Strings Equal）

英小文字からなる 2 つの同じ長さの文字列 `s` と `t` が与えられます。

あなたは `s` に対して次の操作を **任意回数** 行えます。

* 操作: あるインデックス `i` を選び、`s[i]` を **次の文字**に 1 つ進める

  * `'a' -> 'b' -> ... -> 'z' -> 'a'`（`z` の次は `a` に戻る）

あなたのタスクは：

> `s` を `t` に一致させるために必要な操作回数の最小値を求めてください。
> ただし、**同じインデックス `i` に対して行う操作は、必ず前回その `i` に操作した時刻より `k` 以上後でなければならない**
> （つまり、同じ位置を連続で叩けない “クールダウン” 制約がある）とします。

ここで「時刻」は操作回数を 1 ずつ増やすカウンタで表し、最初の操作時刻は 0 とします。

操作を行わない時間（待機）はできません。つまり各時刻で必ずどこかのインデックスを 1 回操作します。

もし制約を満たしつつ `s` を `t` に一致させることができない場合は `-1` を返してください。

### 制約（目安）

* `1 ≤ len(s) = len(t) ≤ 10^5`
* `0 ≤ k ≤ 10^5`
* `s`, `t` は `'a'`〜`'z'`

## 実行例

```python
# 例1
s = "abc"
t = "bcd"
k = 1
# それぞれ 1 回ずつ進めればよい（a->b, b->c, c->d）
# 同じインデックスは連続で触れないが、別インデックスを順番に叩けばOK
# 最小操作回数 = 3
# 出力: 3

# 例2
s = "a"
t = "z"
k = 2
# a を z にするには 25 回シフトが必要
# しかし同じインデックスを触るには 2 時刻空ける必要がある。
# 1 つしかインデックスがないため、連続操作できず待機も不可 → 不可能
# 出力: -1

# 例3
s = "az"
t = "ba"
k = 1
# インデックス0: a->b (1回)
# インデックス1: z->a (1回)
# 交互に叩けるので可能。最小操作回数=2
# 出力: 2
```

## 実行結果

```
例1: abc bcd k= 1 => 3
例2: a z k= 2 => -1
例3: az ba k= 1 => 2
```
