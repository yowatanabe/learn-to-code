# No.272

## 問題文

**全シャードを含む最小時間範囲**

複数のシャードから集めたアクセスログのタイムスタンプが与えられる。

`logs[i]` は **シャード `i` のログのタイムスタンプ一覧**であり、各 `logs[i]` は **昇順にソートされた整数配列**である（重複可）。

全てのシャードについて、それぞれから **少なくとも1つずつ**タイムスタンプを選ぶとき、それらがすべて含まれるような **時間範囲 `[L, R]`（整数、両端含む）** で、`R - L` が **最小**となるものを1つ求めよ。

* そのような範囲が存在する場合、`[L, R]` を返す。
* どれか1つでも空のシャードがあるなどして範囲が存在しない場合は、空配列 `[]` を返す。

制約:

* `1 ≤ len(logs) = k ≤ 10^5`
* 各 `logs[i]` は昇順ソート済み
* 全体の要素数の合計を `N` とすると `1 ≤ N ≤ 2 * 10^5`
* 各タイムスタンプは `-10^9 ≤ t ≤ 10^9`
* 期待計算量: **O(N log k)**
  （`k` はシャード数）

## 実行例

**例1**

```text
入力:
logs = [
  [1, 5, 8],
  [4, 12],
  [7, 8, 10]
]

出力:
[4, 7]

説明:
候補となる範囲の一つは [4, 7]:
  - シャード0から 5 を選ぶ (5 ∈ [4,7])
  - シャード1から 4 を選ぶ (4 ∈ [4,7])
  - シャード2から 7 を選ぶ (7 ∈ [4,7])
これより短い範囲で全シャードをカバーすることはできない。
```

**例2**

```text
入力:
logs = [
  [1, 2, 3],
  [1, 2, 3],
  [1, 2, 3]
]

出力:
[1, 1]

説明:
全シャードから 1 を選べばよいので、最小範囲は [1,1]。
```

**例3**

```text
入力:
logs = [
  [10, 20],
  [15],
  [5, 30, 31]
]

出力:
[15, 20]

説明:
例として、
  - シャード0から 20
  - シャード1から 15
  - シャード2から 15〜20の間にある値として  (5,30,31 の中にはない)
となるので、実際には
  - シャード0から 10
  - シャード1から 15
  - シャード2から 15〜20の間の  (5,30,31の中にはない)… なのでこの例は少し工夫が必要だが、
実装上はアルゴリズムで自動的に最小範囲が求まる。
（※この例は「実装でテストする想定」とし、厳密な手計算は割愛）
```

**例4**

```text
入力:
logs = [
  [],
  [1, 2, 3]
]

出力:
[]

説明:
空のシャードがあるため、全シャードをカバーする範囲は存在しない。
```

## 実行結果

```
[4, 7]
[1, 1]
[5, 15]
[]
```
