# No.270

## 問題文

**依存タスクの実行順序（トポロジカルソート）**

`n` 個のタスクがあり、ID は `0` から `n-1` の整数で表される。

依存関係は配列 `deps` として与えられ、`deps[i] = [a, b]` は

> 「タスク `a` を実行するには **事前にタスク `b` を完了しておく必要がある**」

ことを意味する（＝ `b -> a` の向きの依存）。

すべての依存関係を満たしながら **全タスクをちょうど一度ずつ実行する順序** を 1 つ返せ。

* そのような順序が存在しない場合（依存が循環している場合など）は、空配列 `[]` を返せ。

制約:

* `1 ≤ n ≤ 2 * 10^5`
* `0 ≤ len(deps) ≤ 2 * 10^5`
* 各 `deps[i] = [a, b]` について `0 ≤ a, b < n` かつ `a != b`
* 期待計算量: **O(n + len(deps))**
* 追加メモリ: **O(n + len(deps))**

## 実行例

**例1**

```text
入力:
n = 4
deps = [
  [2, 0],  # 2 をやるには 0 が必要
  [2, 1],  # 2 をやるには 1 が必要
  [3, 2]   # 3 をやるには 2 が必要
]

出力の一例:
[0, 1, 2, 3]

説明:
- 0,1 は前提がないのでどちらを先にやってもよい
- 2 は 0,1 の後
- 3 は 2 の後
他にも [1,0,2,3] など順序は複数ありうるが、依存を守っていればOK。
```

**例2**

```text
入力:
n = 3
deps = [
  [1, 0],
  [2, 1]
]

出力の一例:
[0, 1, 2]
```

**例3**

```text
入力:
n = 3
deps = [
  [0, 1],
  [1, 2],
  [2, 0]
]

出力:
[]

説明:
0->1->2->0 という循環依存があるため、全タスクを完了できる順序は存在しない。
```

**例4**

```text
入力:
n = 2
deps = []

出力の一例:
[0, 1]

説明:
依存がないのでどんな順序でもよい。
```

## 実行結果

```
[0, 1, 2, 3]
[0, 1, 2]
[]
[0, 1]
```
