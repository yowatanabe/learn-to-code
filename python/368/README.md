# No.368

## 問題: ログの欠損を埋める最小日数（Minimum Days to Make Bouquets）

運用ログの欠損補完をイメージしてください。

整数配列 `bloomDay` が与えられます。`bloomDay[i]` は i 番目の要素が利用可能になる日（1日目から）を表します。

あなたは「連続する要素」を使ってまとまり（ブーケ）を作りたいです。

- 1つのブーケは **連続する `k` 個**の要素から作られます
- 合計で **`m` 個**のブーケを作りたいです
- ある日 `D` において、`bloomDay[i] <= D` の要素のみが利用可能です

> `m` 個のブーケを作れるようになる **最小の日数** を返してください。
> 不可能なら `-1` を返してください。

### 制約（目安）

- `1 ≤ len(bloomDay) ≤ 10^5`
- `1 ≤ bloomDay[i] ≤ 10^9`
- `1 ≤ m, k ≤ 10^5`

期待解法: 二分探索 + 判定（O(n log maxDay)）

## 実行例

```python
# 例1
bloomDay = [1,10,3,10,2]
m = 3
k = 1
# 1個ずつなら、3個集まる最小日は 3（1,2,3 が使える）
# 出力: 3

# 例2
bloomDay = [1,10,3,10,2]
m = 3
k = 2
# 連続2個が必要なので不可能
# 出力: -1

# 例3
bloomDay = [7,7,7,7,12,7,7]
m = 2
k = 3
# day=12 で [7,7,7] と [7,7,12] では12が含まれOK、最小は 12
# 出力: 12
```

## 実行結果

```
例1 入力: bloomDay=[1, 10, 3, 10, 2], m=3, k=1
例1 出力: 3 (期待値: 3)
------------------------------------------------------------
例2 入力: bloomDay=[1, 10, 3, 10, 2], m=3, k=2
例2 出力: -1 (期待値: -1)
------------------------------------------------------------
例3 入力: bloomDay=[7, 7, 7, 7, 12, 7, 7], m=2, k=3
例3 出力: 12 (期待値: 12)
------------------------------------------------------------
```
