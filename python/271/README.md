# No.271

## 問題文

**次に高いレイテンシまでの時間**

分ごとのレイテンシ（応答時間, ms）を表す整数配列 `latency` が与えられる。

各インデックス `i` について、**時刻 `i` 以降で、現在よりもレイテンシが厳密に大きくなる最初の時刻 `j`** を考える（`j > i` かつ `latency[j] > latency[i]`）。

* そのような `j` が存在する場合、`answer[i] = j - i`（何分後に高いレイテンシが来るか）
* 存在しない場合、`answer[i] = 0`

となる配列 `answer` を求めよ。

* `0 ≤ len(latency) ≤ 2 * 10^5`
* `-10^9 ≤ latency[i] ≤ 10^9`
* 時間計算量: **O(n)**（スタックなどを用いる）
* 追加メモリ: **O(n)**

## 実行例

**例1**

```text
入力:
latency = [30, 40, 35, 50, 45]

出力:
[1, 2, 1, 0, 0]

説明:
i=0: 30 → 次に大きいのは 40 (i=1) → 1分後
i=1: 40 → 次に大きいのは 50 (i=3) → 2分後
i=2: 35 → 次に大きいのは 50 (i=3) → 1分後
i=3: 50 → 以降にこれより大きい値はない → 0
i=4: 45 → 以降にこれより大きい値はない → 0
```

**例2**

```text
入力:
latency = [100, 90, 80]

出力:
[0, 0, 0]

説明:
どの位置から見ても、それ以降に厳密に大きなレイテンシは現れない。
```

**例3**

```text
入力:
latency = [10, 20, 30, 40]

出力:
[1, 1, 1, 0]

説明:
右に行くほど単調増加なので、各要素は「1分後」が次に大きい値になる。
最後はそれ以降がないので 0。
```

**例4**

```text
入力:
latency = []

出力:
[]
```

## 実行結果

```
[1, 2, 1, 0, 0]
[0, 0, 0]
[1, 1, 1, 0]
[]
```
