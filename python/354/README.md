# No.354

## 問題文（Medium）

### ログ窓の最短抽出（Minimum Window Subsequence of Events）

あなたはSREとして、イベントIDの時系列ログ `logs` を監視している。

ある障害シグナルとして、**指定されたイベント列 `pattern`（順序は維持、連続でなくてよい＝部分列）** が発生した区間を最小長で切り出したい。

`logs`（長さ N）と `pattern`（長さ M）が与えられる。
`pattern` を **部分列として含む** `logs` の連続部分配列（window）のうち、**長さが最小**のものを求めよ。

* 条件：

  * `pattern` の要素は順序通りに出現していればよい（間に別イベントが挟まってOK）
  * 最小長の window が複数ある場合は、**開始インデックスが最小**のものを選ぶ
* 出力：

  * 最小 window を `logs[l:r+1]` として出力せよ
  * そのような window が存在しない場合は空配列 `[]` を出力せよ

**制約（目安）**

* `1 <= N <= 2 * 10^5`
* `1 <= M <= 2000`
* `logs[i]`, `pattern[i]` は整数（イベントID）

## 実行例

```text
logs    = [7, 1, 2, 9, 3, 2, 1, 4, 2, 3]
pattern = [1, 2, 3]
出力: [1, 2, 9, 3]
説明:
[1,2,9,3] は 1→2→3 を順に含む最短の連続区間（長さ4）。
```

```text
logs    = [5, 1, 4, 2, 6, 3]
pattern = [1, 2, 3]
出力: [1, 4, 2, 6, 3]
```

```text
logs    = [1, 2, 2, 1, 2]
pattern = [1, 2, 3]
出力: []
```

## 実行結果

```
logs=[7, 1, 2, 9, 3, 2, 1, 4, 2, 3], pattern=[1, 2, 3] -> [1, 2, 9, 3]
logs=[5, 1, 4, 2, 6, 3], pattern=[1, 2, 3] -> [1, 4, 2, 6, 3]
logs=[1, 2, 2, 1, 2], pattern=[1, 2, 3] -> []
```
