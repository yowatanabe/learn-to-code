# No.257

## 問題文

**LRUキャッシュを実装せよ**

キャパシティ（最大保持件数）`capacity` を持つ LRU (Least Recently Used) キャッシュを設計・実装せよ。

次の2つのメソッドをサポートすること:

* `get(key) -> int`

  * `key` が存在すればその値を返し、そのキーを「最近使われたもの」として扱う。
  * 存在しなければ `-1` を返す。
* `put(key, value) -> None`

  * `key` が既に存在する場合は値を更新し、そのキーを「最近使われたもの」として扱う。
  * `key` が存在しない場合は新規に追加する。
  * このとき、キャッシュ容量を超える場合は「最も最近使われていない」キーを1つ削除する。

**要求:**

* 両メソッドとも平均 O(1) 時間で動作すること。
* 値は整数とする。
* `capacity` は `1 ≤ capacity ≤ 10^5`
* `get` / `put` は最大で `2 * 10^5` 回呼ばれる可能性がある。

## 実行例

以下の操作列を順に実行したときの戻り値を示す:

```
capacity = 2
操作と戻り値:
put(1, 10)     # キャッシュ: {1=10}
put(2, 20)     # キャッシュ: {1=10, 2=20}  (2が最新)
get(1)   -> 10 # 1が使われたので 1 が最新になる
put(3, 30)     # capacity=2 を超えるので、一番古いキー=2を削除
get(2)   -> -1 # 2は追い出された
get(3)   -> 30
put(1, 15)     # 1の値を更新(10→15)、1が最新になる
get(1)   -> 15
get(3)   -> 30
```

この場合の出力シーケンスは:

```
[10, -1, 30, 15, 30]
```

## 実行結果

```
10
-1
30
15
30
```
