# No.296

## 問題: ジャンプゲーム（最後のインデックスに到達できるか）

非負整数からなる配列 `nums` が与えられます。
`nums[i]` は、インデックス `i` から **最大で** 右方向に何マス進めるか（ジャンプできる距離の上限）を表します。

あなたは最初、インデックス `0` にいます。

> 配列の **最後のインデックス（`len(nums) - 1`）に到達できるかどうか** を判定してください。

* 到達できる場合は `True`（または `1`）として扱っても良いですが、ここでは Python っぽく `True/False` を返すものとします。
* 途中でジャンプ距離が 0 のマスに乗ってもかまいませんが、そこから先に進めない場合もあります。

### 制約（目安）

* `1 ≤ len(nums) ≤ 10^5`
* `0 ≤ nums[i] ≤ 10^5`

時間計算量 **O(n)** の解法（貪欲法）を意識してください。

ナイーブに「すべての経路を試す」ような再帰・バックトラックは TLE 想定です。

## 実行例

```python
# 例1
nums = [2, 3, 1, 1, 4]
# インデックス0からスタート:
# - 0番目(値2)から 1 or 2 マス先へ行ける
#   0 -> 1 -> 4 と進めば、最後のインデックス4に到達できる
# 出力: True

# 例2
nums = [3, 2, 1, 0, 4]
# インデックス0からスタート:
# 最大3マス先まで行けるので
#   0 -> 1 or 2 or 3 に行けるが、
#   3番目は値0なので、そこから先に進めない
# どのルートを辿ってもインデックス4には到達できない
# 出力: False

# 例3
nums = [0]
# 最初から最後(インデックス0)にいるので到達可能とみなす
# 出力: True

# 例4
nums = [2, 0, 0]
# 0番目から最大2マス進めるので、直接インデックス2に到達できる
# 出力: True
```

## 実行結果

```
例1の入力: [2, 3, 1, 1, 4]
例1の結果: True
例2の入力: [3, 2, 1, 0, 4]
例2の結果: False
例3の入力: [0]
例3の結果: True
例4の入力: [2, 0, 0]
例4の結果: True
```
